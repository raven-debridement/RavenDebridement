#!/usr/bin/env python

import roslib
roslib.load_manifest('RavenDebridement')
import rospy

import functools, argparse
import cPickle as pickle
from collections import defaultdict

from raven_2_msgs.msg import RavenState
from geometry_msgs.msg import PoseStamped

from RavenDebridement.Utils import Constants

import tfx

class DataRecorder(object):
    def __init__(self, arms=['L','R']):
        self.arms = arms
        self.camera_to_robot_tf = None
        self.camera_poses = defaultdict(list)
        self.robot_poses = defaultdict(list)
        self.robot_joints = defaultdict(list)
        self.estimated_poses = defaultdict(list)
        
        self.is_recording = True
        
        for arm in self.arms:
            rospy.Subscriber(Constants.GripperTape.Topic+'_'+arm, PoseStamped, functools.partial(self._tape_pose_cb,arm))
            rospy.Subscriber('/estimated_gripper_pose_'+arm, PoseStamped, functools.partial(self._est_pose_cb,arm))
        
        rospy.Subscriber(Constants.RavenTopics.RavenState, RavenState, self._raven_state_cb)
    
    def _tape_pose_cb(self, arm, msg):
        if not self.is_recording:
            return
        
        if self.camera_to_robot_tf is None:
            self.camera_to_robot_tf = tfx.lookupTransform('/0_link', msg.header.frame_id).array
        
        pose = tfx.pose(msg)
        self.camera_poses[arm].append((pose.stamp.seconds,pose.array))
    
    def _est_pose_cb(self, arm, msg):
        if not self.is_recording:
            return
        
        if self.camera_to_robot_tf is None:
            self.camera_to_robot_tf = tfx.lookupTransform('/0_link', msg.header.frame_id).array
        
        pose = tfx.pose(msg)
        self.estimated_poses[arm].append((pose.stamp.seconds,pose.array))
    
    def _raven_state_cb(self, msg):
        if not self.is_recording:
            return
        
        for arm in self.arms:
            arm_msg = [arm_ for arm_ in msg.arms if arm_.name == arm][0]
            pose = tfx.pose(arm_msg.tool.pose,header=msg.header)
            self.robot_poses[arm].append((pose.stamp.seconds,pose.array))
            joints = tuple(j.position for j in arm_msg.joints)
            self.robot_joints[arm].append((pose.stamp.seconds,joints))
    
    def write(self,fp):
        if isinstance(fp,basestring):
            fp = open(fp,'w')
        
        d = {}
        for key in ['camera_to_robot_tf','camera_poses','robot_poses','robot_joints','estimated_poses']:
            d[key] = getattr(self,key)
        
        pickle.dump(d, fp)
        
    def stop_recording(self):
        self.is_recording = False
        
    def start_recording(self):
        self.is_recording = True

def main():
    rospy.init_node('data_recorder',anonymous=True)
    parser = argparse.ArgumentParser()
    
    parser.add_argument('file_name',nargs='?',default='data.pkl')
    parser.add_argument('--pause',action='store_true')
    
    args = parser.parse_args()
    
    recorder = DataRecorder()
    
    if args.pause:
        recorder.stop_recording()
        while not rospy.is_shutdown():
            rospy.loginfo('Press enter to record')
            raw_input()
            recorder.start_recording()
            rospy.loginfo('Press enter to stop recording')
            raw_input()
            recorder.stop_recording()
    
    print 'Gathering data...'
    
    rospy.spin()
    
    print 'Saving data...'
    recorder.write(args.file_name)
    print 'done'

if __name__ == '__main__':
    main()